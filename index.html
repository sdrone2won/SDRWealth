<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SDRWEALTH | System</title>
    <style>
        :root {
            --primary: #FFEA00;
            --success: #00FF41;
            --bg-body: #000000;
            --font-mono: "SF Mono", "Fira Code", monospace;
            --card-width: 280px;
            --card-height: 380px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: #000;
            background: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #0f0f1a 40%, #000000 100%);
            background-size: 200% 200%;
            animation: deep-breath 12s ease-in-out infinite alternate;
            
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            height: 100vh; width: 100vw;
            overflow: hidden;
            color: white;
            cursor: default;
            touch-action: none;
        }

        @keyframes deep-breath {
            0% { background-position: 40% 40%; }
            100% { background-position: 60% 60%; }
        }

        /* --- CANVAS --- */
        #neuralCanvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }

        /* --- UI LAYER --- */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 30px;
        }

        #boot-screen {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #000; z-index: 999;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column;
            transition: opacity 0.8s ease-out;
            pointer-events: none;
        }

        .boot-logo {
            font-size: 1.5rem; font-weight: 900; letter-spacing: 4px; color: #fff;
            animation: glow-pulse 2s infinite alternate;
        }
        .boot-logo span { color: var(--primary); }
        
        @keyframes glow-pulse {
            from { text-shadow: 0 0 10px rgba(255, 255, 255, 0.1); opacity: 0.8; }
            to { text-shadow: 0 0 20px rgba(255, 234, 0, 0.4); opacity: 1; }
        }

        /* --- 3D MARKERS --- */
        #labels-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
            overflow: hidden;
            perspective: 1000px;
        }

        .node-marker {
            position: absolute; top: 0; left: 0;
            transform: translate3d(-50%, -50%, 0);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; 
            cursor: pointer;
            will-change: transform, opacity;
            -webkit-font-smoothing: antialiased;
        }

        /* The Transforming Container */
        .marker-ring {
            width: 40px; height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            position: relative;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 1, 0.5, 1); 
        }

        .marker-image {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.4s ease 0.1s;
        }

        .marker-dot {
            width: 8px; height: 8px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transition: 0.3s;
        }

        .marker-label {
            margin-top: 15px;
            text-align: center;
            opacity: 0; 
            transform: translateY(10px);
            transition: all 0.3s ease-out;
        }

        .marker-title { 
            display: block; font-size: 12px; font-weight: 800; color: #fff; 
            letter-spacing: 2px; text-shadow: 0 2px 4px rgba(0,0,0,1);
        }
        .marker-sub { 
            display: block; font-size: 9px; color: #888; 
            font-family: var(--font-mono); margin-top: 4px; letter-spacing: 1px;
        }

        /* --- STATES --- */

        /* Visible when close enough */
        .node-marker.visible .marker-label { opacity: 0.7; transform: translateY(0); }
        
        /* Focused (Axis) */
        .node-marker.focused .marker-ring {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(255, 234, 0, 0.2);
            transform: scale(1.2);
        }
        .node-marker.focused .marker-dot { background: var(--primary); }
        .node-marker.focused .marker-label { opacity: 1; }

        /* Expanded (Green Interface) */
        .node-marker.expanded { z-index: 1000 !important; }
        
        .node-marker.expanded .marker-ring {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: 12px;
            border: 1px solid var(--success);
            background: #050505;
            box-shadow: 0 0 60px rgba(0, 255, 65, 0.1);
            transform: scale(1) !important;
        }

        .node-marker.expanded .marker-dot { opacity: 0; }
        .node-marker.expanded .marker-image { opacity: 1; }
        .node-marker.expanded .marker-label { margin-top: 20px; opacity: 1; }
        .node-marker.expanded .marker-sub { color: var(--success); content: "ACCESS GRANTED"; }

    </style>
</head>
<body>

    <div id="boot-screen">
        <div class="boot-logo">SDR<span>WEALTH</span></div>
    </div>

    <canvas id="neuralCanvas"></canvas>
    <div id="labels-container"></div>
    <div class="ui-layer"></div>

<script>
    /**
     * CONFIGURATION
     */
    const CONFIG = {
        particleCount: 800,      // High density
        universeSize: 3000,      // Universe size
        connectDist: 300,        // Connection range
        
        startZoom: 1600,         
        minZoom: 100,            
        maxZoom: 4000,           
        
        labelFadeStart: 1500,    // Distance to show text
        orbitThreshold: 450,     // Distance to trigger "Green Card"
        
        autoRotate: 0.0003,      
        dragSpeed: 0.005,
        zoomSpeed: 3,
        panSpeed: 0.06           
    };

    /**
     * SITEMAP DATA
     */
    const NAV_NODES = [
        // 1. AFM (Center)
        { 
            id: 'afm', title: 'AFM', sub: 'PROTOCOL', link: 'afm/index.html', 
            img: 'assets/AFM-banner.jpg', 
            x: 0, y: 0, z: 0 
        },
        // 2. The Apex (New Node - Top Rightish)
        { 
            id: 'apex', title: 'THE APEX', sub: 'COMMUNITY', link: 'https://discord.gg/ncrWWRwUjt', 
            img: 'assets/apex.png',
            x: 600, y: -600, z: -400 
        },
        // 3. Pre-Reset (Deep Right)
        { 
            id: 'reset', title: 'PRE-RESET', sub: 'PROTOCOL', link: '#', 
            img: 'assets/pre-reset.jpg',
            x: 800, y: -200, z: 600 
        },
        // 4. IG (Deep Left)
        { 
            id: 'ig', title: 'INSTAGRAM', sub: 'ACCESS', link: 'https://instagram.com', 
            img: 'https://images.unsplash.com/photo-1611162617474-5b21e879e113?q=80&w=500&auto=format&fit=crop',
            x: -800, y: 300, z: -400 
        },
        // 5. About (Top Back)
        { 
            id: 'about', title: 'ABOUT', sub: 'SOURCE', link: '#', 
            img: 'assets/SDR.png',
            x: 200, y: -900, z: -800 
        },
        // 6. Contact (Bottom Front)
        { 
            id: 'contact', title: 'CONTACT', sub: 'ENCRYPTED', link: '#', 
            img: 'https://images.unsplash.com/photo-1555421689-491a97ff2040?q=80&w=500&auto=format&fit=crop',
            x: -300, y: 800, z: 800 
        }
    ];

    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    const labelsDiv = document.getElementById('labels-container');
    const bootScreen = document.getElementById('boot-screen');

    let width, height;

    // --- STATE ---
    let particles = [];
    
    let cameraZ = CONFIG.startZoom;
    let targetCameraZ = CONFIG.startZoom;
    
    // Rotation State
    let rotX = 0, rotY = 0;
    let targetRotX = 0, targetRotY = 0;

    let currentAxis = { x: 0, y: 0, z: 0 };
    let targetAxis = { x: 0, y: 0, z: 0 };
    let focusedNode = null;

    // Input Logic
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let hasMoved = false;
    let lastX = 0, lastY = 0;

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    /**
     * PARTICLE SYSTEM
     */
    class Particle {
        constructor(isNode = false, nodeData = null) {
            this.isNode = isNode;
            this.nodeData = nodeData;
            this.init();
        }

        init() {
            if (this.isNode) {
                this.x = this.nodeData.x;
                this.y = this.nodeData.y;
                this.z = this.nodeData.z;
            } else {
                this.x = (Math.random() - 0.5) * CONFIG.universeSize;
                this.y = (Math.random() - 0.5) * CONFIG.universeSize;
                this.z = (Math.random() - 0.5) * CONFIG.universeSize;
            }
            this.sx = 0; this.sy = 0; this.scale = 0; this.zDepth = 0;
            this.alpha = 0;
        }

        update() {
            // Infinite Recycling Logic (XYZ Wrapping)
            if (!this.isNode) {
                let rx = this.x - currentAxis.x;
                let ry = this.y - currentAxis.y;
                let rz = this.z - currentAxis.z;
                
                if (rz > cameraZ + 500) this.z -= CONFIG.universeSize;
                if (rz < -CONFIG.universeSize/2) this.z += CONFIG.universeSize;
                
                const bound = CONFIG.universeSize / 1.5;
                if (rx > bound) this.x -= CONFIG.universeSize;
                if (rx < -bound) this.x += CONFIG.universeSize;
                if (ry > bound) this.y -= CONFIG.universeSize;
                if (ry < -bound) this.y += CONFIG.universeSize;
            }

            // 1. Shift World
            let rx = this.x - currentAxis.x;
            let ry = this.y - currentAxis.y;
            let rz = this.z - currentAxis.z;

            // 2. Rotation
            let x1 = rx * Math.cos(rotY) - rz * Math.sin(rotY);
            let z1 = rz * Math.cos(rotY) + rx * Math.sin(rotY);
            let y1 = ry * Math.cos(rotX) - z1 * Math.sin(rotX);
            let z2 = z1 * Math.cos(rotX) + ry * Math.sin(rotX);

            // 3. Projection
            let zDepth = z2 + cameraZ;

            if (zDepth <= 10) {
                this.scale = 0; return;
            }

            let perspective = 800 / zDepth;
            
            this.sx = x1 * perspective + width / 2;
            this.sy = y1 * perspective + height / 2;
            this.scale = perspective;
            this.zDepth = zDepth;
            
            // Fade Logic (Slightly brighter in distance for visibility)
            this.alpha = Math.min(1, (4500 - zDepth) / 1000);
            if (this.alpha < 0) this.alpha = 0;
        }
    }

    function initGame() {
        particles = [];
        labelsDiv.innerHTML = '';

        NAV_NODES.forEach(node => {
            const p = new Particle(true, node);
            particles.push(p);
            createLabel(p);
        });

        for (let i = 0; i < CONFIG.particleCount; i++) {
            particles.push(new Particle(false));
        }

        setTimeout(() => {
            bootScreen.style.opacity = 0;
            setTimeout(() => bootScreen.style.display = 'none', 800);
        }, 800);

        loop();
    }

    function createLabel(particle) {
        const node = particle.nodeData;
        const el = document.createElement('div');
        el.className = 'node-marker';
        el.id = `label-${node.id}`;
        
        el.innerHTML = `
            <div class="marker-ring">
                <img src="${node.img}" class="marker-image" alt="${node.title}" loading="lazy">
                <div class="marker-dot"></div>
            </div>
            <div class="marker-label">
                <span class="marker-title">${node.title}</span>
                <span class="marker-sub">${node.sub}</span>
            </div>
        `;

        el.addEventListener('click', (e) => {
            e.stopPropagation();

            if (focusedNode === particle) {
                if (particle.zDepth < CONFIG.orbitThreshold + 150) {
                    window.location.href = node.link;
                } else {
                    targetCameraZ = CONFIG.orbitThreshold;
                }
            } else {
                setFocus(particle);
                if (targetCameraZ > 1200) targetCameraZ = 900;
            }
        });

        el.addEventListener('mouseenter', () => {
            if (isDragging) return;
            // Sticky Logic
            if (focusedNode && targetCameraZ < CONFIG.orbitThreshold + 300 && focusedNode !== particle) {
                return;
            }
            setFocus(particle);
        });

        labelsDiv.appendChild(el);
    }

    function setFocus(particle) {
        if (focusedNode && focusedNode !== particle) {
            const oldEl = document.getElementById(`label-${focusedNode.nodeData.id}`);
            if (oldEl) {
                oldEl.classList.remove('focused');
                oldEl.classList.remove('expanded');
            }
        }

        focusedNode = particle;
        
        if (particle) {
            const el = document.getElementById(`label-${particle.nodeData.id}`);
            if(el) el.classList.add('focused');
            targetAxis = { x: particle.x, y: particle.y, z: particle.z };
        } else {
            targetAxis = { x: 0, y: 0, z: 0 };
            document.querySelectorAll('.node-marker').forEach(el => {
                el.classList.remove('focused');
                el.classList.remove('expanded');
            });
        }
    }

    // ----------------------------------------------------------------
    // RENDER LOOP
    // ----------------------------------------------------------------

    function loop() {
        ctx.clearRect(0, 0, width, height);

        // Physics
        cameraZ += (targetCameraZ - cameraZ) * 0.1;
        if (!isDragging) targetRotY += CONFIG.autoRotate;
        
        rotX += (targetRotX - rotX) * 0.1;
        rotY += (targetRotY - rotY) * 0.1;

        currentAxis.x += (targetAxis.x - currentAxis.x) * CONFIG.panSpeed;
        currentAxis.y += (targetAxis.y - currentAxis.y) * CONFIG.panSpeed;
        currentAxis.z += (targetAxis.z - currentAxis.z) * CONFIG.panSpeed;

        // Particle Update
        particles.forEach(p => p.update());
        particles.sort((a, b) => b.zDepth - a.zDepth);

        ctx.lineWidth = 1;
        
        // Draw
        for (let i = 0; i < particles.length; i++) {
            let p1 = particles[i];
            if (p1.scale <= 0) continue;

            // Connections
            let checkLimit = 5;
            for (let j = 1; j < checkLimit; j++) {
                if (i + j >= particles.length) break;
                let p2 = particles[i + j];
                if (p2.scale <= 0) continue;

                let dx = p1.sx - p2.sx;
                let dy = p1.sy - p2.sy;
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < CONFIG.connectDist * p1.scale) {
                    let alpha = (1 - (dist / (CONFIG.connectDist * p1.scale)));
                    
                    if (p1.isNode || p2.isNode) {
                         ctx.strokeStyle = `rgba(255, 234, 0, ${alpha * 0.4})`;
                    } else {
                         ctx.strokeStyle = `rgba(100, 100, 100, ${alpha * 0.15})`;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.sx, p1.sy);
                    ctx.lineTo(p2.sx, p2.sy);
                    ctx.stroke();
                }
            }

            // Draw Node / Star
            if (p1.isNode) {
                updateDOM(p1);
                
                // GLOW CAP
                let glowRaw = 60 * p1.scale;
                let glowSize = Math.min(glowRaw, 150); 

                let g = ctx.createRadialGradient(p1.sx, p1.sy, 0, p1.sx, p1.sy, glowSize);
                g.addColorStop(0, 'rgba(255, 234, 0, 0.2)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(p1.sx, p1.sy, glowSize, 0, Math.PI * 2); ctx.fill();

            } else {
                // Background Stars
                let drawAlpha = p1.alpha * 1.5; 
                ctx.fillStyle = `rgba(220, 220, 220, ${Math.min(1, drawAlpha)})`;
                ctx.beginPath();
                ctx.arc(p1.sx, p1.sy, 2 * p1.scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        requestAnimationFrame(loop);
    }

    function updateDOM(p) {
        const el = document.getElementById(`label-${p.nodeData.id}`);
        if (!el) return;

        if (p.scale > 0 && p.zDepth > 50) {
            el.style.display = 'flex';
            
            // UI Scale Logic
            let isExpanded = el.classList.contains('expanded');
            let uiScale = isExpanded ? 1 : Math.min(p.scale, 1.2);
            if (uiScale < 0.1) uiScale = 0.1;

            el.style.transform = `translate3d(${p.sx}px, ${p.sy}px, 0) translate(-50%, -50%) scale(${uiScale})`;
            el.style.zIndex = Math.floor(10000 - p.zDepth);
            el.style.opacity = p.alpha;

            // Visibility
            if (p.zDepth < CONFIG.labelFadeStart) el.classList.add('visible');
            else el.classList.remove('visible');

            // EXPANSION CHECK
            const isAxis = (focusedNode === p);
            const isClose = (p.zDepth < CONFIG.orbitThreshold);
            
            if (isAxis && isClose) {
                el.classList.add('expanded');
            } else {
                el.classList.remove('expanded');
            }

        } else {
            el.style.display = 'none';
        }
    }

    // ----------------------------------------------------------------
    // INPUTS
    // ----------------------------------------------------------------

    window.addEventListener('click', (e) => {
        if (!isDragging && !hasMoved && !e.target.closest('.node-marker')) {
            setFocus(null);
            if(targetCameraZ < 500) targetCameraZ = 1200;
        }
    });

    function onStart(x, y) {
        if (event.target.closest('.node-marker')) return;
        isDragging = true; hasMoved = false;
        dragStartX = x; dragStartY = y;
        lastX = x; lastY = y;
        document.body.style.cursor = 'grabbing';
    }

    function onMove(x, y) {
        if (isDragging) {
            if (Math.abs(x - dragStartX) > 5 || Math.abs(y - dragStartY) > 5) hasMoved = true;
            
            // AXIS CLAMP FIX
            targetRotY += (x - lastX) * CONFIG.dragSpeed; 
            targetRotX += (y - lastY) * CONFIG.dragSpeed; 
            targetRotX = Math.max(-1.5, Math.min(1.5, targetRotX));

            lastX = x; lastY = y;
        }
    }

    function onEnd() {
        isDragging = false;
        document.body.style.cursor = 'default';
    }

    function onZoom(delta) {
        targetCameraZ += delta * CONFIG.zoomSpeed;
        if (targetCameraZ < CONFIG.minZoom) targetCameraZ = CONFIG.minZoom;
        if (targetCameraZ > CONFIG.maxZoom) targetCameraZ = CONFIG.maxZoom;
    }

    window.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', onEnd);
    window.addEventListener('wheel', e => onZoom(e.deltaY), { passive: true });

    let pinchDist = 0;
    window.addEventListener('touchstart', e => {
        if(e.touches.length === 1) onStart(e.touches[0].clientX, e.touches[0].clientY);
        if(e.touches.length === 2) {
            let dx = e.touches[0].clientX - e.touches[1].clientX;
            let dy = e.touches[0].clientY - e.touches[1].clientY;
            pinchDist = Math.sqrt(dx*dx + dy*dy);
        }
    }, { passive: false });

    window.addEventListener('touchmove', e => {
        e.preventDefault();
        if(e.touches.length === 1) onMove(e.touches[0].clientX, e.touches[0].clientY);
        if(e.touches.length === 2) {
            let dx = e.touches[0].clientX - e.touches[1].clientX;
            let dy = e.touches[0].clientY - e.touches[1].clientY;
            let dist = Math.sqrt(dx*dx + dy*dy);
            onZoom((pinchDist - dist) * 4);
            pinchDist = dist;
        }
    }, { passive: false });
    window.addEventListener('touchend', onEnd);

    initGame();

</script>
</body>
</html>